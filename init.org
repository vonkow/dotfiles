* Init and Monkeypatch
** Preamble
   In order to have this cool org-ified init file, .emacs does a few
things. This includes calling package-initialize and loading org before 
evaluating this file.
** All about Packages
   Gotta configure how we get packages before getting them, duh
*** Other repos
    ELPA is cool, but MELPA is ice cold. Get packages from both.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives 
    (cons "melpa"  "https://melpa.org/packages/"))
#+END_SRC
*** Using use-package
    Use =use-package= to load packages. =:ensure= and =:defer= by default
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  
  (require 'use-package)

  (setq use-package-always-ensure t
        use-package-always-defer t)
#+END_SRC
** Pathing is silly
   Use the shell's path, not stupid Mac OS path
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell)
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
#+END_SRC
** Custom is sillier
   No clutter from custom in =.emacs=
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/init-custom.el")
  (load-file custom-file)
#+END_SRC
** Splash screen is also silly (for now)
   Be rid of it until you find a more useful one
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC
* Packages and config
  Emacs has good functions, but let's add gooderer ones
** Bindings
*** Evil, etc
   Can't be too holy, after all
*** Evil
    Vi til I die
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand
    :config (evil-mode 1))
  (require 'evil)
#+END_SRC
*** Some Extra Evil Packages
    Misery loves company
**** We have you surrounded
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround)
  (require 'evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC
*** General.el
    It claims to be a more evil-leader
#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand)
  (require 'general)
#+END_SRC
** Navigation
*** Which key?
    So we can see what's bound to what
#+BEGIN_SRC emacs-lisp
  (use-package which-key :demand)
  (which-key-mode)
#+END_SRC
*** Helm
    Because Ivy was a little *too* minimalistic
#+BEGIN_SRC emacs-lisp
  (use-package helm-core
    :ensure t)

  (use-package helm
    :ensure t
    :config (progn
              (setq helm-buffers-fuzzy-matching t)
              (helm-mode 1)))

  (use-package helm-descbinds
    :ensure t)
  ; TODO helm-swoop if it looks coole

  (use-package helm-ag
    :ensure helm-ag)
#+END_SRC
*** Projectile
    Manage yo shit
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-global-mode)
    (setq projectile-mode-line
          '(:eval (format " [%s]" (projectile-project-name))))
    (setq projectile-remember-window-configs t)
    (setq projectile-completion-system 'ivy))

  (use-package helm-projectile
    :ensure t
    ;:general 
    ;(project-stuff-map
      ;:wk-full-keys nil
      ;"f" '(helm-projectile-find-file-dwim :wk "find file")
      ;"s" '(helm-projectile-ag :wk "search")))
    )
#+END_SRC
*** Counsel
    Clearly, it does something.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  ;:bind
  ;("M-x" . counsel-M-x)
  ;("C-z f" . counsel-describe-function)
  ;("C-z v" . counsel-describe-variable)
  ;("C-c k" . counsel-ag)
  )
#+END_SRC
**** TODO learn why we care about this package
** Search
*** Ag
    The silver surfer will probably be replaced by faster search someday.
    Heavy is the head that wears the crown.
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t
    :config
    (add-hook 'ag-mode-hook 'toggle-truncate-lines)
    (setq ag-highlight-search t)
    (setq ag-reuse-buffers 't))
#+END_SRC
** Completion and Checking
   Flycheck seemed good, let's also try company
*** TODO Figure out if both work together or what
*** Languages
**** Python
     Anaconda maybe?
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode)
  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
  (use-package nose)
#+END_SRC
*** Modes
**** Web Stuff
#+BEGIN_SRC emacs-lisp
  (use-package web-mode)
  (use-package mmm-mode)
#+END_SRC
*** Company
#+BEGIN_SRC emacs-lisp
  (use-package company-go
    :ensure t)

  (use-package company-jedi
    :ensure t)

  (use-package company
    :ensure t
    :diminish company-mode
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :bind
    ("M-/" . company-complete-common)
    :config
    (defun my/python-mode-hook ()
      (add-to-list 'company-backends 'company-jedi))
    (add-hook 'python-mode-hook 'my/python-mode-hook)
    (add-to-list 'company-backends 'company-go)
    (setq company-dabbrev-downcase nil))
  (require 'company)
#+END_SRC
*** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (setq flycheck-check-syntax-automatically '(mode-enabled save))
    (add-hook 'python-mode-hook 'flycheck-mode)
    (add-hook 'go-mode-hook 'flycheck-mode)
    (add-hook 'sh-mode-hook 'flycheck-mode)
    (add-hook 'rst-mode-hook 'flycheck-mode)
    (add-hook 'js-mode-hook 'flycheck-mode))
  (require 'flycheck)
#+END_SRC
** Org
   Installed by bootstrap, hence the cool org-ified init file.
*** Make Org Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :ensure t
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme))))
  (add-hook 'org-mode-hook #'(lambda () (electric-indent-local-mode 0)))
  (add-hook 'org-mode-hook #'(lambda () (setq evil-auto-indent nil)))
#+END_SRC
*** Babel
    This should at least sorta make init.org fun to edit
#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate #'(lambda (lang body)
    (not (or (string= lang "emacs-lisp")
             (string= lang "python")))))

  (org-babel-do-load-languages 
    'org-babel-load-languages
    '((emacs-lisp . t)
      (python . t)
      (ditaa . t)))
#+END_SRC
*** Capture Templates
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
    '(("T" "Work TODO" entry (file+datetree "~/org/rover.org")
           "TODO %?\n")
      ("O" "Work One-pager" entry (file+olp "~/org/rover.org" "One-Pagers")
           "** %?\n*** What?\n*** Why?\n*** How?\n*** Open Questions")
     ))
#+END_SRC
*** TODO Make paredit work in babel'd files
** Terminals
   Yay for shell
*** Terminals are like buffers, you need more than one
#+BEGIN_SRC emacs-lisp
  (use-package multi-term)
  (setq multi-term-program "/bin/zsh")
#+END_SRC
** VC
   You can't have holy evil without some amount of control
*** Magit
    Is awesome, use it.
#+BEGIN_SRC emacs-lisp
  (use-package magit)
  (use-package evil-magit :ensure t)
  (require 'evil-magit)
#+END_SRC
**** TODO Add git timemachine 
** Paredit and lisp thisgs
#+BEGIN_SRC emacs-lisp
  (use-package paredit)
  (require 'paredit)
  ; The below could use auditing and maybe expanding to make this file work with paredit too
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
#+END_SRC
* Keybindings
** Buffers
   Everything's a buffer, man
#+BEGIN_SRC emacs-lisp
  (defvar buffer-stuff-map (make-sparse-keymap)
    "Buffer Shortcuts")
  (general-define-key
    :keymaps 'buffer-stuff-map
    :wk-full-keys nil
    "b" '(buffer-menu :wk "buffers"))
#+END_SRC
** Files
#+BEGIN_SRC emacs-lisp
  (defvar file-stuff-map (make-sparse-keymap)
    "File Shortcuts")
  (general-define-key
    :keymaps 'file-stuff-map
    :wk-full-keys nil
    "f" '(find-file :wk "find file"))
#+END_SRC
** Project
#+BEGIN_SRC emacs-lisp
  (defvar project-stuff-map (make-sparse-keymap)
    "Project Shortcuts")
  (general-define-key
    :keymaps 'project-stuff-map
    :wk-full-keys nil
    "f" '(helm-projectile-find-file-dwim :wk "find file")
    "s" '(helm-projectile-ag :wk "search"))
#+END_SRC
** Git
#+BEGIN_SRC emacs-lisp
  (defvar git-stuff-map (make-sparse-keymap)
    "Git Shortcuts")
  (general-define-key
    :keymaps 'git-stuff-map
    :wk-full-keys nil
    "s" '(magit :wk "magit"))
#+END_SRC
** Org
#+BEGIN_SRC emacs-lisp
  (defvar org-stuff-map (make-sparse-keymap)
    "Org Shortcuts")
  (general-define-key
    :keymaps 'org-stuff-map
    :wk-full-keys nil
    "c" '(org-capture :wk "capture"))
#+END_SRC
** Root Leader Keybindings
#+BEGIN_SRC emacs-lisp
  (general-create-definer zee-leader :keymaps 'normal :prefix "SPC")
  (zee-leader
    "" '(nil :which-key "Leader")
    "SPC" 'execute-extended-command
    "p" '(:keymap project-stuff-map :which-key "project")
    "b" '(:keymap buffer-stuff-map :which-key "buffers")
    "f" '(:keymap file-stuff-map :which-key "files")
    "g" '(:keymap git-stuff-map :which-key "git")
    "o" '(:keymap org-stuff-map :which-key "org")
    "h" '(:ignore t :which-key "halp"))
#+END_SRC
** Core Keybindings
   Help, etc
*** Help
#+BEGIN_SRC emacs-lisp
  ;(general-define-key :prefix "SPC h"
    ;"h" 'help-command)
  
  ;(declare-named-prefix "h" "halp")
  ;(evil-leader/set-key "hh" 'help-command)
#+END_SRC
** Dirs
   Directories are just files of files, but they are special
#+BEGIN_SRC emacs-lisp
  ;(declare-named-prefix "d" "directories")
  ;(evil-leader/set-key "dd" 'dired)
#+END_SRC
** Procs
   Processes are, like, buffers in action or maybe they're files come to 
life and maybe life is just a stream of ones, zeros, and the occasional 
null to keep it interesting and piss off the static typers?
#+BEGIN_SRC emacs-lisp
  ;(declare-named-prefix "P" "processes")
  ;(evil-leader/set-key "Pp" 'proced)
#+END_SRC
** Search
   If you can't find it, does it really exist?
#+BEGIN_SRC emacs-lisp
  ;(declare-named-prefix "s" "search")
  ;(evil-leader/set-key "sp" 'helm-projectile-ag)
  ;(evil-leader/set-key "sa" 'counsel-ag)
#+END_SRC
** Org
   This'll need a lot of work
#+BEGIN_SRC emacs-lisp
  ;(evil-leader/set-key-for-mode 'org-mode
  ;  "TAB" 'org-cycle
  ;  "t" 'org-todo)
#+END_SRC
*** TODO Add more org keys or use a package
** Magit
   Is really awesome
#+BEGIN_SRC emacs-lisp
;(evil-leader/set-key "g" 'magit-status)

;(defun my-setup-local-with-editor-keys ()
  ;(evil-local-set-key 'normal ",," 'with-editor-finish)
  ;(evil-local-set-key 'normal ",k" 'with-editor-cancel))

;(add-hook 'with-editor-mode-hook #'my-setup-local-with-editor-keys)
#+END_SRC
*** TODO Add hotkey for blame
*** TODO Make q quit in blame
** Lispy Things
   Probably move these somewhere else someday
#+BEGIN_SRC emacs-lisp
  ;(declare-named-prefix "l" "lisp")
  ;(evil-leader/set-key "ll" 'eval-last-sexp)
#+END_SRC

** Multiterm
#+BEGIN_SRC emacs-lisp
  ;(evil-leader/set-key "'" 'multi-term)

;(add-hook 'term-mode-hook
          ;(lambda ()
            ;(add-to-list 'term-bind-key-alist '(",p" . multi-term-prev))
            ;(add-to-list 'term-bind-key-alist '(",n" . multi-term-next))))
#+END_SRC
** Moar Keybindings
   Misc shit
#+BEGIN_SRC emacs-lisp
  ;(evil-leader/set-key "." 'find-init-file)
  ;; what's this for?
  ;(setq-default indent-tabs-mode nil)
#+END_SRC
*** TODO Move these somewhere better
* GUI, Theme and Font
  Nicer font, solarized, no GUI, statusbar
#+BEGIN_SRC emacs-lisp
;(use-package color-theme-sanityinc-solarized)
;(color-theme-sanityinc-solarized-light)
;(color-theme-sanityinc-solarized-dark)
(use-package github-modern-theme)
;(load-theme 'github-modern t)
(load-theme 'tango-dark t)

(set-face-attribute 'default nil
                    :family "Source Code Pro"
                    :height 160
                    :weight 'normal
                    :width 'normal)

(menu-bar-mode -1)
(toggle-scroll-bar -1)
(tool-bar-mode -1)

;; TODO MOve to packages area
(use-package smart-mode-line-powerline-theme)
(use-package smart-mode-line)
(setq sml/theme 'respectful)
(sml/setup)
#+END_SRC
* Old, but interesting inner workings
** +DIY Leader+
   Keep it simple, stupid
#+BEGIN_SRC emacs-lisp
  ;(defvar base-leader-map (make-sparse-keymap)
    ;"Base leader keymap")
  ;(define-key evil-normal-state-map (kbd "SPC") base-leader-map)
#+END_SRC
** +Add the ability to name prefixes+
   Blatantly stolen from spacemacs
#+BEGIN_SRC emacs-lisp
  ;(defun declare-named-prefix (prefix name &optional long-name)
    ;(let* ((command name)
           ;(full-prefix (concat evil-leader/leader " " prefix))
           ;(full-prefix-emacs (concat evil-leader/leader " " prefix))
           ;(full-prefix-lst (listify-key-sequence (kbd full-prefix)))
           ;(full-prefix-emacs-lst (listify-key-sequence
                                   ;(kbd full-prefix-emacs))))
      ;(unless long-name (setq long-name name))
      ;(which-key-declare-prefixes
        ;full-prefix-emacs (cons name long-name)
        ;full-prefix (cons name long-name)))) 

  ;; Not sure we need this 
  ;(put 'declare-named-prefix 'lisp-indent-function 'defun)
#+END_SRC
** +Slack maybe?+
#+BEGIN_SRC emacs-lisp
;(el-get-bundle slack)
;(use-package oauth2)
;(use-package websocket)
;(use-package request)
;(use-package circe)
;(use-package emojify)
;(use-package slack
;  :commands (slack-start)
;  :init
;  (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
;  (setq slack-prefer-current-team t)
;  :config
;  (slack-register-team
;    :name "roverdotcom"
;    :default t
;    :client-id "3044291641.244028430790"
;    :client-secret "cceebfee26330ce5c056d3d3b1d34c2d"
;    :subscribed-channels '(
;      dilla komondors komondors-web ops tech
;      board-gaming catpeople rpg
;      basenjis goldador ibizans maremmas newfies ridgebacks
;      5th_floor_seattle craft-beer-kids gaming rover_pics roverdotcom
;      android app-reviews data deploys dilla-cx dilla-wiz ios mobile-support product rover-oss tech-emergency updates-data-model updates-product
;      yak-shaving)
;  )

  ;; (evil-define-key 'normal slack-info-mode-map
    ;; ",u" 'slack-room-update-messages)
  ;; (evil-define-key 'normal slack-mode-map
    ;; ",c" 'slack-buffer-kill
    ;; ",ra" 'slack-message-add-reaction
    ;; ",rr" 'slack-message-remove-reaction
    ;; ",rs" 'slack-message-show-reaction-users
    ;; ",pl" 'slack-room-pins-list
    ;; ",pa" 'slack-message-pins-add
    ;; ",pr" 'slack-message-pins-remove
    ;; ",mm" 'slack-message-write-another-buffer
    ;; ",me" 'slack-message-edit
    ;; ",md" 'slack-message-delete
    ;; ",u" 'slack-room-update-messages
    ;; ",2" 'slack-message-embed-mention
    ;; ",3" 'slack-message-embed-channel
    ;; "\C-n" 'slack-buffer-goto-next-message
    ;; "\C-p" 'slack-buffer-goto-prev-message)
   ;; (evil-define-key 'normal slack-edit-message-mode-map
    ;; ",k" 'slack-message-cancel-edit
    ;; ",s" 'slack-message-send-from-buffer
    ;; ",2" 'slack-message-embed-mention
    ;; ",3" 'slack-message-embed-channel)
;  )

;(use-package alert
;  :commands (alert)
;  :init
;  (setq alert-default-style 'notifier))
#+END_SRC

